import { useEffect, useMemo, useRef, useState } from "react";
import { Navigate, Route, Routes, useLocation, useNavigate } from "react-router-dom";
import PortalLayout from "../layout/PortalLayout";
import { useAuth } from "../auth/AuthContext";
import { normalizeEmail } from "../auth/localAuth";
import { useAppData } from "../state/AppDataContext";

const customerMenuBase = [
  { label: "Dashboard", path: "/customer/dashboard" },
  { label: "Find Services", path: "/customer/services" },
  { label: "My Bookings", path: "/customer/bookings" },
  { label: "Messages", path: "/customer/messages" },
  { label: "Settings", path: "/customer/settings" }
];

const readSeenTimestamp = (storageKey) => {
  if (!storageKey) return 0;
  const raw = Number(localStorage.getItem(storageKey));
  return Number.isFinite(raw) && raw > 0 ? raw : 0;
};

const saveSeenTimestamp = (storageKey, timestamp) => {
  if (!storageKey) return;
  localStorage.setItem(storageKey, String(timestamp));
};

const readThreadSeenMap = (storageKey) => {
  if (!storageKey) return {};
  try {
    const parsed = JSON.parse(localStorage.getItem(storageKey) || "{}");
    if (!parsed || typeof parsed !== "object") return {};

    return Object.entries(parsed).reduce((acc, [threadId, seenAt]) => {
      const numericSeenAt = Number(seenAt);
      if (Number.isFinite(numericSeenAt) && numericSeenAt > 0) {
        acc[threadId] = numericSeenAt;
      }
      return acc;
    }, {});
  } catch {
    return {};
  }
};

const saveThreadSeenMap = (storageKey, seenMap) => {
  if (!storageKey) return;
  localStorage.setItem(storageKey, JSON.stringify(seenMap));
};

const toEpochMs = (value) => {
  const parsed = new Date(value || "").getTime();
  return Number.isFinite(parsed) && parsed > 0 ? parsed : 0;
};

const getMessageEpochMs = (message = {}) => {
  const createdAtMs = toEpochMs(message.createdAt);
  if (createdAtMs > 0) return createdAtMs;

  const idMatch = String(message.id || "").match(/^msg-(\d+)-/);
  if (!idMatch) return 0;

  const idTime = Number(idMatch[1]);
  return Number.isFinite(idTime) && idTime > 0 ? idTime : 0;
};

const CustomerDashboard = () => {
  const location = useLocation();
  const navigate = useNavigate();
  const { user, updateUser } = useAuth();
  const {
    portalData,
    saveCustomerProfile,
    resetCustomerProfile,
    createBookingRequest,
    addBookingMessage,
    bookingStatusLabel
  } = useAppData();

  const customerEmail = normalizeEmail(user?.email || portalData.customerProfile.email || "");
  const [filter, setFilter] = useState("All");
  const [locationFilter, setLocationFilter] = useState("");
  const [customerDraft, setCustomerDraft] = useState(portalData.customerProfile);
  const [feedback, setFeedback] = useState("");
  const [chatText, setChatText] = useState("");
  const [activeChatBookingId, setActiveChatBookingId] = useState("");
  const [slotChoiceByService, setSlotChoiceByService] = useState({});
  const [lastSeenBookingsAt, setLastSeenBookingsAt] = useState(0);
  const [threadSeenMap, setThreadSeenMap] = useState({});
  const attachmentRef = useRef(null);

  useEffect(() => {
    setCustomerDraft(portalData.customerProfile);
  }, [portalData.customerProfile]);

  const approvedProviders = useMemo(() => {
    const deduped = new Map();
    portalData.providerQueue.forEach((provider) => {
      if (provider.status !== "APPROVED") return;
      const providerKey = normalizeEmail(provider.email);
      if (!providerKey) return;
      deduped.set(providerKey, provider);
    });
    return Array.from(deduped.values());
  }, [portalData.providerQueue]);

  const approvedProviderEmailSet = useMemo(
    () => new Set(approvedProviders.map((provider) => normalizeEmail(provider.email))),
    [approvedProviders]
  );

  const providerProfileByEmail = useMemo(() => {
    const map = new Map();
    portalData.providerProfiles.forEach((profile) => {
      const key = normalizeEmail(profile.providerEmail);
      if (!key) return;
      map.set(key, profile);
    });
    return map;
  }, [portalData.providerProfiles]);

  const marketplaceServices = useMemo(() => {
    return portalData.providerServiceCatalog
      .filter((service) => {
        const providerEmail = normalizeEmail(service.providerEmail);
        if (!approvedProviderEmailSet.has(providerEmail)) return false;
        if (!service.available) return false;
        return Number(service.price) > 0;
      })
      .map((service) => {
        const providerEmail = normalizeEmail(service.providerEmail);
        const provider =
          approvedProviders.find((entry) => normalizeEmail(entry.email) === providerEmail) || null;
        const profile = providerProfileByEmail.get(providerEmail);
        const slots =
          portalData.providerSettings?.[providerEmail]?.selectedSlots ||
          provider?.selectedSlots ||
          [];

        return {
          ...service,
          providerName: provider?.name || service.providerName,
          providerLocation: provider?.area || provider?.address || service.providerLocation,
          providerEmail,
          providerRating: Number(profile?.rating || 0),
          providerReviews: Number(profile?.reviews || 0),
          providerCompletedJobs: Number(profile?.completedJobs || 0),
          slots
        };
      })
      .sort((a, b) => {
        const byCategory = a.category.localeCompare(b.category);
        if (byCategory !== 0) return byCategory;
        return a.subcategory.localeCompare(b.subcategory);
      });
  }, [
    portalData.providerServiceCatalog,
    portalData.providerSettings,
    approvedProviderEmailSet,
    approvedProviders,
    providerProfileByEmail
  ]);

  const categories = useMemo(() => {
    const categorySet = new Set(["All"]);
    marketplaceServices.forEach((service) => categorySet.add(service.category));
    return Array.from(categorySet);
  }, [marketplaceServices]);

  const filteredServices = useMemo(() => {
    return marketplaceServices.filter((service) => {
      const categoryMatches = filter === "All" || service.category === filter;
      const locationMatches = !locationFilter.trim()
        ? true
        : String(service.providerLocation || "")
            .toLowerCase()
            .includes(locationFilter.trim().toLowerCase());
      return categoryMatches && locationMatches;
    });
  }, [marketplaceServices, filter, locationFilter]);

  const customerBookings = useMemo(
    () =>
      portalData.bookings
        .filter((booking) => normalizeEmail(booking.customerEmail) === customerEmail)
        .sort((a, b) => new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime()),
    [portalData.bookings, customerEmail]
  );

  const acceptedBookings = useMemo(
    () => customerBookings.filter((booking) => booking.status === "ACCEPTED"),
    [customerBookings]
  );

  const bookingSeenStorageKey = customerEmail
    ? `fixitnow_seen_customer_bookings_${customerEmail}`
    : "";
  const threadSeenStorageKey = customerEmail
    ? `fixitnow_seen_customer_thread_messages_${customerEmail}`
    : "";

  useEffect(() => {
    if (!customerEmail) {
      setLastSeenBookingsAt(0);
      setThreadSeenMap({});
      return;
    }

    setLastSeenBookingsAt(readSeenTimestamp(bookingSeenStorageKey));
    setThreadSeenMap(readThreadSeenMap(threadSeenStorageKey));
  }, [customerEmail, bookingSeenStorageKey, threadSeenStorageKey]);

  const isIncomingProviderMessage = (booking, message) => {
    const role = String(message?.senderRole || "").toUpperCase();
    if (role === "PROVIDER") return true;
    if (role === "CUSTOMER" || role === "SYSTEM" || role === "ADMIN") return false;

    const senderEmail = normalizeEmail(message?.senderEmail || "");
    const bookingProviderEmail = normalizeEmail(booking?.providerEmail || "");
    if (!senderEmail || !bookingProviderEmail) {
      return String(message?.from || "").trim().toLowerCase() !== "system";
    }
    return Boolean(senderEmail && bookingProviderEmail && senderEmail === bookingProviderEmail);
  };

  useEffect(() => {
    if (!customerEmail) return;

    const now = Date.now();
    if (location.pathname.startsWith("/customer/bookings")) {
      setLastSeenBookingsAt(now);
      saveSeenTimestamp(bookingSeenStorageKey, now);
    }
  }, [location.pathname, customerEmail, bookingSeenStorageKey]);

  useEffect(() => {
    if (!location.pathname.startsWith("/customer/messages")) return;

    const nextSeen = { ...threadSeenMap };
    let changed = false;

    acceptedBookings.forEach((booking) => {
      const latestIncomingAt = (portalData.bookingMessages[booking.id] || []).reduce(
        (latest, message) => {
          if (!isIncomingProviderMessage(booking, message)) return latest;
          return Math.max(latest, getMessageEpochMs(message));
        },
        0
      );

      if (latestIncomingAt <= 0) return;
      if ((nextSeen[booking.id] || 0) >= latestIncomingAt) return;

      nextSeen[booking.id] = latestIncomingAt;
      changed = true;
    });

    if (!changed) return;

    setThreadSeenMap(nextSeen);
    saveThreadSeenMap(threadSeenStorageKey, nextSeen);
  }, [
    location.pathname,
    acceptedBookings,
    portalData.bookingMessages,
    threadSeenStorageKey,
    threadSeenMap
  ]);

  const customerBookingUpdateCount = useMemo(
    () =>
      customerBookings.filter(
        (booking) =>
          booking.status !== "PENDING" &&
          toEpochMs(booking.updatedAt || booking.createdAt) > lastSeenBookingsAt
      ).length,
    [customerBookings, lastSeenBookingsAt]
  );

  const customerUnreadMessageByBookingId = useMemo(
    () =>
      acceptedBookings.reduce((map, booking) => {
        const seenAt = threadSeenMap[booking.id] || 0;
        const unreadInThread = (portalData.bookingMessages[booking.id] || []).filter(
          (message) => isIncomingProviderMessage(booking, message) && getMessageEpochMs(message) > seenAt
        ).length;

        map[booking.id] = unreadInThread;
        return map;
      }, {}),
    [acceptedBookings, portalData.bookingMessages, threadSeenMap]
  );

  const customerUnreadMessageCount = useMemo(
    () =>
      Object.values(customerUnreadMessageByBookingId).reduce((sum, count) => sum + Number(count || 0), 0),
    [customerUnreadMessageByBookingId]
  );

  const customerBookingBadgeCount = customerBookingUpdateCount;
  const customerMessageBadgeCount = customerUnreadMessageCount;

  const customerMenu = useMemo(
    () =>
      customerMenuBase.map((item) => {
        if (item.path === "/customer/bookings") {
          return { ...item, badgeCount: customerBookingBadgeCount };
        }
        if (item.path === "/customer/messages") {
          return { ...item, badgeCount: customerMessageBadgeCount };
        }
        return item;
      }),
    [customerBookingBadgeCount, customerMessageBadgeCount]
  );

  useEffect(() => {
    if (!acceptedBookings.length) {
      setActiveChatBookingId("");
      return;
    }

    const exists = acceptedBookings.some((booking) => booking.id === activeChatBookingId);
    if (!exists) {
      setActiveChatBookingId(acceptedBookings[0].id);
    }
  }, [acceptedBookings, activeChatBookingId]);

  const activeChatBooking = useMemo(
    () => acceptedBookings.find((booking) => booking.id === activeChatBookingId) || null,
    [acceptedBookings, activeChatBookingId]
  );

  const activeChatMessages = activeChatBooking
    ? portalData.bookingMessages[activeChatBooking.id] || []
    : [];

  const createBooking = (service) => {
    if (!customerEmail) {
      setFeedback("Please login again to continue booking.");
      return;
    }

    const selectedSlot = slotChoiceByService[service.id] || service.slots[0] || "";
    createBookingRequest({
      customerName: customerDraft.name || portalData.customerProfile.name || "Customer",
      customerEmail,
      customerLocation: customerDraft.location || portalData.customerProfile.location,
      providerEmail: service.providerEmail,
      category: service.category,
      subcategory: service.subcategory,
      price: service.price,
      selectedSlot
    });

    setFeedback(
      `${service.providerName} booking request created for ${service.subcategory}. Provider will accept or reject soon.`
    );
  };

  const openProviderChat = (booking) => {
    setActiveChatBookingId(booking.id);
    navigate("/customer/messages");
  };

  const saveCustomerSettings = () => {
    saveCustomerProfile(customerDraft);
    if (user?.role === "CUSTOMER") {
      updateUser({
        name: customerDraft.name,
        email: customerDraft.email
      });
    }
    setFeedback("Customer profile updated successfully.");
  };

  const resetCustomerSettings = () => {
    resetCustomerProfile();
    setFeedback("Customer profile reset.");
  };

  const sendMessage = () => {
    if (!activeChatBooking) {
      setFeedback("Chat starts only after provider accepts booking.");
      return;
    }

    const text = chatText.trim();
    if (!text) {
      setFeedback("Please type a message before sending.");
      return;
    }

    addBookingMessage({
      bookingId: activeChatBooking.id,
      from: customerDraft.name || portalData.customerProfile.name || "Customer",
      text,
      senderRole: "CUSTOMER",
      senderEmail: customerEmail
    });
    setChatText("");
    setFeedback(`Message sent to ${activeChatBooking.providerName}.`);
  };

  const attachPhoto = () => {
    attachmentRef.current?.click();
  };

  const onAttachmentChosen = (e) => {
    const file = e.target.files?.[0];
    if (!file) return;
    setFeedback(`Attached: ${file.name}`);
  };

  const CustomerHome = () => (
    <>
      <section className="portal-card portal-hero">
        <div>
          <h2>Welcome back, {portalData.customerProfile.name || "Customer"}!</h2>
          <p>
            Browse approved providers, compare prices with location, and track your booking status.
          </p>
        </div>
        <button className="portal-button" onClick={() => navigate("/customer/services")}>
          Find Services Near Me
        </button>
      </section>

      <section className="portal-grid">
        <article className="portal-metric">
          <p className="portal-metric-value">{marketplaceServices.length}</p>
          <p className="portal-metric-label">Live service listings</p>
          <p className="portal-metric-note portal-ok">From approved providers only</p>
        </article>
        <article className="portal-metric">
          <p className="portal-metric-value">{customerBookings.length}</p>
          <p className="portal-metric-label">My bookings</p>
          <p className="portal-metric-note portal-warn">
            {customerBookings.filter((booking) => booking.status === "PENDING").length} pending response
          </p>
        </article>
        <article className="portal-metric">
          <p className="portal-metric-value">{acceptedBookings.length}</p>
          <p className="portal-metric-label">Accepted bookings</p>
          <p className="portal-metric-note portal-ok">Chat enabled for accepted jobs</p>
        </article>
        <article className="portal-metric">
          <p className="portal-metric-value">{portalData.customerProfile.location || "N/A"}</p>
          <p className="portal-metric-label">Default location</p>
          <p className="portal-metric-note">Used to speed up booking</p>
        </article>
      </section>

      <section className="portal-list-grid">
        {marketplaceServices.slice(0, 3).map((service) => (
          <article className="portal-list-card" key={service.id}>
            <h4>{service.subcategory}</h4>
            <p className="portal-list-sub">{service.providerName}</p>
            <p className="portal-list-sub">Category: {service.category}</p>
            <p className="portal-list-sub">Location: {service.providerLocation}</p>
            <p className="portal-list-sub">
              {service.providerRating.toFixed(1)} rating | {service.providerReviews} reviews |{" "}
              {service.providerCompletedJobs} jobs
            </p>
            <p className="portal-price">Rs.{service.price}</p>
            <span className="portal-status ok">Approved Provider</span>
            <div className="portal-button-row">
              <button className="portal-button" onClick={() => createBooking(service)}>
                Book Now
              </button>
            </div>
          </article>
        ))}
      </section>
    </>
  );

  const CustomerServices = () => (
    <section className="portal-card">
      <div className="portal-title-row">
        <h3>Service Marketplace</h3>
        <p>Filter by category and provider location</p>
      </div>

      <div className="portal-form-grid">
        <div className="portal-field">
          <label>Category</label>
          <div className="portal-chip-row">
            {categories.map((category) => (
              <button
                type="button"
                className={`portal-chip ${filter === category ? "portal-chip-active" : ""}`}
                key={category}
                onClick={() => setFilter(category)}
              >
                {category}
              </button>
            ))}
          </div>
        </div>
        <div className="portal-field">
          <label>Provider location filter</label>
          <input
            type="text"
            placeholder="Type area/location"
            value={locationFilter}
            onChange={(e) => setLocationFilter(e.target.value)}
          />
        </div>
      </div>

      <div className="portal-list-grid" style={{ marginTop: 14 }}>
        {filteredServices.length === 0 && (
          <article className="portal-list-card">
            <h4>No services found</h4>
            <p className="portal-list-sub">Try changing category or location filter.</p>
          </article>
        )}

        {filteredServices.map((service) => (
          <article className="portal-list-card" key={service.id}>
            <h4>{service.subcategory}</h4>
            <p className="portal-list-sub">{service.providerName}</p>
            <p className="portal-list-sub">Category: {service.category}</p>
            <p className="portal-list-sub">Provider Location: {service.providerLocation}</p>
            <p className="portal-list-sub">
              {service.providerRating.toFixed(1)} rating | {service.providerReviews} reviews
            </p>
            <p className="portal-price">Rs.{service.price}</p>
            <span className="portal-status ok">Approved Provider</span>

            <div className="portal-field" style={{ marginTop: 10 }}>
              <label>Preferred slot</label>
              <select
                value={slotChoiceByService[service.id] || service.slots[0] || ""}
                onChange={(e) =>
                  setSlotChoiceByService((prev) => ({
                    ...prev,
                    [service.id]: e.target.value
                  }))
                }
              >
                {service.slots.length === 0 && <option value="">Provider slots not configured</option>}
                {service.slots.map((slot) => (
                  <option key={slot} value={slot}>
                    {slot}
                  </option>
                ))}
              </select>
            </div>

            <div className="portal-button-row">
              <button className="portal-button" onClick={() => createBooking(service)}>
                Book Provider
              </button>
            </div>
          </article>
        ))}
      </div>
    </section>
  );

  const CustomerBookings = () => (
    <section className="portal-card">
      <div className="portal-title-row">
        <h3>Recent Bookings</h3>
        <p>Provider accept/reject status is shown live</p>
      </div>

      <div className="portal-list">
        {customerBookings.length === 0 && (
          <article className="portal-list-item">
            <h5>No bookings yet</h5>
            <p>Create a booking from Find Services.</p>
          </article>
        )}

        {customerBookings.map((booking) => (
          <article className="portal-list-item" key={booking.id}>
            <h5>{booking.subcategory}</h5>
            <p>
              {booking.providerName} | {booking.providerLocation}
            </p>
            <p>
              {booking.category} | Rs.{booking.price}
            </p>
            <span className={`portal-status ${booking.tone}`}>
              {bookingStatusLabel(booking.status)}
            </span>

            {booking.status === "ACCEPTED" && (
              <div className="portal-button-row">
                <button className="portal-button" onClick={() => openProviderChat(booking)}>
                  Chat Provider
                </button>
              </div>
            )}
          </article>
        ))}
      </div>
    </section>
  );

  const CustomerMessages = () => (
    <section className="portal-split">
      <article className="portal-card">
        <div className="portal-title-row">
          <h3>Conversations</h3>
          <p>{customerUnreadMessageCount} unread</p>
        </div>

        <div className="portal-chip-row">
          {acceptedBookings.map((booking) => {
            const unreadCount = customerUnreadMessageByBookingId[booking.id] || 0;
            return (
              <button
                key={booking.id}
                type="button"
                className={`portal-chip ${activeChatBookingId === booking.id ? "portal-chip-active" : ""}`}
                onClick={() => setActiveChatBookingId(booking.id)}
              >
                <span>{booking.providerName}</span>
                {unreadCount > 0 && (
                  <span className="portal-chip-notify">{unreadCount > 99 ? "99+" : unreadCount}</span>
                )}
              </button>
            );
          })}
        </div>

        {!acceptedBookings.length && (
          <div className="portal-list" style={{ marginTop: 12 }}>
            <div className="portal-list-item">
              <h5>No active chat yet</h5>
              <p>Chat will open when a provider accepts your booking.</p>
            </div>
          </div>
        )}
      </article>

      <article className="portal-card">
        <div className="portal-title-row">
          <h3>Message Preview</h3>
          <p>Two-way communication after provider acceptance</p>
        </div>

        <div className="portal-list">
          {activeChatMessages.map((message) => (
            <div className="portal-list-item" key={message.id}>
              <h5>{message.from}</h5>
              <p>{message.text}</p>
            </div>
          ))}
        </div>

        <div className="portal-field">
          <label>Reply</label>
          <textarea
            placeholder={
              activeChatBooking
                ? "Type your message here..."
                : "Wait for provider acceptance to start chat"
            }
            value={chatText}
            onChange={(e) => setChatText(e.target.value)}
            disabled={!activeChatBooking}
          />
        </div>

        <input
          ref={attachmentRef}
          type="file"
          accept=".png,.jpg,.jpeg,.pdf"
          style={{ display: "none" }}
          onChange={onAttachmentChosen}
        />

        <div className="portal-button-row">
          <button className="portal-button" onClick={sendMessage} disabled={!activeChatBooking}>
            Send
          </button>
          <button className="portal-button secondary" onClick={attachPhoto} disabled={!activeChatBooking}>
            Attach Photo
          </button>
        </div>
      </article>
    </section>
  );

  const CustomerSettings = () => (
    <section className="portal-card">
      <div className="portal-title-row">
        <h3>Profile & Preferences</h3>
        <p>Keep your contact and location details updated</p>
      </div>

      <div className="portal-form-grid">
        <div className="portal-field">
          <label>Full name</label>
          <input
            type="text"
            value={customerDraft.name}
            onChange={(e) => setCustomerDraft((prev) => ({ ...prev, name: e.target.value }))}
          />
        </div>
        <div className="portal-field">
          <label>Email</label>
          <input
            type="email"
            value={customerDraft.email}
            onChange={(e) => setCustomerDraft((prev) => ({ ...prev, email: e.target.value }))}
          />
        </div>
        <div className="portal-field">
          <label>Phone</label>
          <input
            type="tel"
            value={customerDraft.phone}
            onChange={(e) =>
              setCustomerDraft((prev) => ({
                ...prev,
                phone: e.target.value.replace(/\D/g, "").slice(0, 10)
              }))
            }
          />
        </div>
        <div className="portal-field">
          <label>Default location</label>
          <input
            type="text"
            value={customerDraft.location}
            onChange={(e) => setCustomerDraft((prev) => ({ ...prev, location: e.target.value }))}
          />
        </div>
      </div>

      <div className="portal-button-row">
        <button className="portal-button" onClick={saveCustomerSettings}>
          Save Changes
        </button>
        <button className="portal-button secondary" onClick={resetCustomerSettings}>
          Reset
        </button>
      </div>
    </section>
  );

  return (
    <PortalLayout portalTitle="Customer" menuItems={customerMenu}>
      {feedback && (
        <section className="portal-card" style={{ borderColor: "rgba(6, 182, 212, 0.6)" }}>
          <p style={{ margin: 0 }}>{feedback}</p>
        </section>
      )}

      <Routes>
        <Route index element={<Navigate to="dashboard" replace />} />
        <Route path="dashboard" element={<CustomerHome />} />
        <Route path="services" element={<CustomerServices />} />
        <Route path="bookings" element={<CustomerBookings />} />
        <Route path="messages" element={<CustomerMessages />} />
        <Route path="settings" element={<CustomerSettings />} />
        <Route path="*" element={<Navigate to="dashboard" replace />} />
      </Routes>
    </PortalLayout>
  );
};

export default CustomerDashboard;
